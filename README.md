---

## 클린아키텍쳐 - 로버트C. 마틴

#

### [Chapter 01]  설계와 아키텍처란? <br/>

1. 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 최소화하는 데 있다.
2. 이 책은 바로 이 내용을 다룬다. 훌륭하고 깔끔한 아키텍처와 설계가 무엇인지 설명하고, 이를 통해 소프트웨어 개발자가 장기간에 걸쳐 수익을 창출하는 시스템을 만들 수 있게 하고자 한다.
 
---

#

### [Chapter 02] 두 가지 가치에 대한 이야기 <br/>

1. 모든 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가지 가치를 제공하는데, 행위와 구조가 바로 그것이다.
2. 소프트웨어는 '부드러움을 지니도록' 만들어졌다. 소프트웨어를 만든 이유는 기계의 행위를 쉽게 변경할 수 있도록 하기 위해서다.
3. 변경사항을 적용하는 데 드는 어려움은 변경되는 범위에 비례해야하며 변경사항의 형태와는 관련이 없어야한다.
4. 아키텍처는 형태에 독립적이여야 하고, 그럴수록 더 실용적이다.
5. 소프트웨어의 첫 번째 가치인 행위는 긴급하지만 매번 높은 중요도를 가지는 것은 아니다.
6. 소프트웨어의 두 번째 가치인 아키텍처는 중요하지만 즉각적인 긴급성을 필요로 하는 경우는 절대 없다.
7. 개발자가 따라야 하는 순서는 다음과 같다
- 긴급하고 중요한
- 긴급하지는 않지만 중요한
- 긴급하지만 중요하지 않은
- 긴급하지도 중요하지도 않은
8. 효율적인 소프트웨어 개발팀은 이러한 투쟁에서 정면으로 맞서 싸운다. 뻔번함을 무릅쓰고 이해관계자들과 동등하게 논쟁한다.
9. 하나만 기억하자. 아키텍쳐가 두번째가 아닌 뒤로 밀리는 순간 개발비용이 더많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.

---

#

### [Chapter 03] 패러다임 개요

1. 첫 번째, 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다(goto문장)
2. 두 번째, 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
3. 세 번째, 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

---

#

### [Chapter 04] 구조적 프로그래밍

1. 테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다.
2. 소프트웨어 개발은 수학적인 시도보다는 과학적잉ㄴ 시도에 가깝다. 최선을 다하더라도 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문이다.
3. 구조적 프로그래밍이 오늘날까지 가치있는 이유는 프로그래밍에서 반증가능한 단위를 만들어낼 수 있는 능력 때문이다.

---

#

### [Chapter 05] 객체지향 프로그래밍

1. 캡슐화를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다.
2. 함수에 대한 포인터를 직접 사용하여 다형적 행위를 만드는 방식에는 문제가 있는데, 함수 포인터는 위험하다는 사실이다.
3. 다형성을 통해 상위 객체 안에 하위 객체를 플러그인처럼 넣을 수 있다.
4. 플러그인 아키텍처는 이처럼 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.
5. 다형성이 없을 때 제어흐름은 시스템의 행위에 따라 결정되며, 소스코드 의존성은 제어흐름에 따라 결졍된다.
6. 다형성이 생기는 순간 소스코드의 의존성(상속관계)이 제어 흐름과는 반대로 진행된다. 이를 의존성 역전이라 부른다.
7. 다형성을 통한 의존성 역전이 가능해지면서 아키텍트는 소스코드 의존성 방향, 제어흐름에 절대적인 권한을 갖는다.
8. 이를 통해 데이터베이스와 UI가 업무규칙에 의존하도록 만들 수 있다. 즉 DB와 UI가 업무규칙의 플러그인이 된다.
9. 시스템 모듈을 독립적으로 배포할 수 있게 되면 각 모듈을 독립적으로 개발할 수 있다. 이것이 바로 개발 독립성이다.

---

#

### [Chapter 06] 함수형 프로그래밍

1. 아키텍트는 왜 변수의 가변성을 염려하는가? 경합조건(Data Race), 교착상태(Data Deadlock), 동시업데이트(Concurrent Update) 문제가 모두 가변 변수로 인해 발생하기 때문이다. 락이 가변적이지 않다면 교착상태도 일어나지 않는다.
2. 불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.
3. 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며 어떤 가변 변수도 사용되지 않는다.
4. 애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야한다는 것이다.
5. 더 많은 메모리를 확보할수록, 기계가 빨라질수록, 필요한 가변상태는 더 적어진다.
6. 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하는 전략이다. 상태가 필요해지면 단순한 상태의 시작점부터 모든 트랜잭션을 처리한다.
7. 중요한 점은 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다는 사실이다. 결과적으로 애플리케이션은 CRUD가 아니라 그저 CR만 수행한다. 또한 저장소에서 변경 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제 또한 일어나지 않는다.

---

# 

### [Chapter 07] SRP: 단일 책임 원칙

1. 단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.
2. 하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야한다
3. 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
4. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.
5. 단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 
6. 컴포넌트 수준에서는 공통 폐쇄 원칙이 된다.
7. 아키텍쳐 수준에서는 경계의 생성을 책임지는 변경의 축이된다.

---

# 

### [Chapter 08] OCP: 개방-폐쇄 원칙

1. 소프트웨어 개체는 확장에는 열려있어야하고, 변경에는 닫혀있어야한다.
2. 이처럼 책임을 분리했다면, 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스코드 의존성도 확실히 조직화해야 한다.
3. 또한 새 조직화된 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야한 다.
4. 다시 한 번 말하지만, A컴포넌트에서 발생한 변경으로부터 B컴포넌트를 보호하려면 반드시 A컴포넌트가 B컴포넌트에 의존해야한다.
5. Interactor를 통해 presenter에서 발생한 변경으로부터 controller를 보호하고자 한다.
6. 왜 Interactor가 중요한가? 그 이유는 바로 Interactor가 업무규칙을 포함하기 때문이다. Interactor는 애플리케이션에서 가장 높은 수준의 정책을 포함한다.
7. 보호의 계층구조가 '수준level'이라는 개념을 바탕으로 어떻게 생성되는지 주목하자. Interator는 가장 높은 수준의 개념이며 따라서 최고의 보호를 받는다.
8. 아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고 분리한 기능을 컴포넌트 계층구조로 조직화 한다. 컴포넌트 계층구조를 이와같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.
9. OCP(개방-폐쇄 원칙) 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야한다.

---

#

### [Chapter 09] LSP: 리스코프 치환 원칙

1. LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 매커니즘을 추가해야할 수도 있다.

---

#

### [Chapter 11] DIP: 의존성 역전 원칙

1. 유연성이 극대화된 시스템이란 소스 코드 의존성이 추상(abstraction)에 의존하며 구체(concretion)에는 의존하지 않는 시스템이다.
2. 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰(volatile) 구체적인 요소다.
3. 매우 구체적인 코딩 실천법은 다음과 같다.
- 변동성이 큰 구체 클래스를 참조라지마라
- 변동성이 큰 구체 클래스로부터 파생하지 말라
- (의존성을 필요로 하는 함수) 구체 함수를 오버라이드 하지 말라
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라
- 94p





